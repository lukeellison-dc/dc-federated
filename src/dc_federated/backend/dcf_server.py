"""
Defines the core server class for the federated learning.
Abstracts away the lower level server logic from the federated
machine learning logic.
"""

import os
import json
import os.path
import zlib
import msgpack
import hashlib
import zmq.green as zmq
import subprocess as sp
import sys

from dc_federated.backend._constants import *
from dc_federated.backend.backend_utils import *
from dc_federated.utils import get_host_ip
from dc_federated.backend.backend_utils import is_valid_model_dict
from dc_federated.backend._worker_manager import WorkerManager
from dc_federated.backend.zqm_interface import ZQMInterfaceModel

import logging

logger = logging.getLogger(__name__)
logger.setLevel(level=logging.INFO)


class DCFServer(object):
    """
    This class abstracts away the lower level communication logic for
    the central server/node from the actual federated learning logic.
    It interacts with the central server node via the 4 callback functions
    passed in the constructor. For an example usage please refer to the
    package dc_federated.example_dcf+model.

    Parameters
    ----------

    register_worker_callback:
        This function is expected to take the id of a newly registered
        worker and should contain the application specific logic for
        dealing with a new worker joining the federated learning pool.

    unregister_worker_callback:
        This function is expected to take the id of a newly unregistered
        worker and should contain the application specific logic for
        dealing with a worker leaving the federated learning pool.

    return_global_model_callback: () -> dict
        This function is expected to return a dictionary with the
        GLOBAL_MODEL: containing the serialization of the global model
        GLOBAL_MODEL_VERSION: the global model version (algorithm specific).

    is_global_model_most_recent:  str -> bool
        Returns the True if the model version given in the string is the
        most recent one - otherwise returns False.

    receive_worker_update_callback: dict -> bool
        This function should receive a worker-id and an application
        dependent binary serialized update from the worker. The
        server code ensures that the worker-id was previously
        registered.

    server_mode_safe: bool
        Whether or not the server should be in safe of unsafe mode. Safe
        mode does not allow unauthenticated workers with the optional initial
        set of public keys passed via the key_list_parameters. Raises
        an exception if server started in unsafe mode and key_list_file
        is not None.

    key_list_file: str
        The name of the file containing the public keys for valid workers.
        The public keys are given one key per line, with each key being
        generated by the worker_key_pair_tool.py tool. If None, then
        no authentication is performed.

    load_last_session_workers: bool (default True)
        When running in safe mode, whether or not to load the workers
        from the previous session.

    path_to_keys_db: str
        Path to the database of workers' public keys that has been added.

    server_host_ip: str (default None)
        The ip-address of the host of the server. If None, then it
        uses the ip-address of the current machine.

    server_port: int (default 8080)
        The port at which the serer should listen to. If None, then it
        uses the port 8080.

    ssl_enabled: bool (default False)
        Enable SSL/TLS for server/workers communications.

    ssl_keyfile: str
        Must be a valid path to the key file.
        This is mandatory if ssl_enabled, ignored otherwise.

    ssl_certfile: str
        Must be a valid path to the certificate.
        This is mandatory if ssl_enabled, ignored otherwise.

    model_check_interval: int
        The interval of time between the server checking for an updated
        model for the long polling.
    """
    def __init__(
        self,
        register_worker_callback,
        unregister_worker_callback,
        return_global_model_callback,
        is_global_model_most_recent,
        receive_worker_update_callback,
        server_mode_safe,
        key_list_file,
        load_last_session_workers=True,
        path_to_keys_db='.keys_db.json',
        server_host_ip=None,
        server_port=8080,
        ssl_enabled=False,
        ssl_keyfile=None,
        ssl_certfile=None,
        model_check_interval=10,
        debug=False,
        socket_port=5555,
    ):
        self.register_worker_callback = register_worker_callback
        self.unregister_worker_callback = unregister_worker_callback
        self.return_global_model_callback = return_global_model_callback
        self.is_global_model_most_recent = is_global_model_most_recent
        self.receive_worker_update_callback = receive_worker_update_callback

        self.server_subprocess_args = {
            'server_mode_safe': server_mode_safe,
            'key_list_file': key_list_file,
            'load_last_session_workers': load_last_session_workers,
            'path_to_keys_db': path_to_keys_db,
            'server_host_ip': server_host_ip,
            'server_port': server_port,
            'ssl_enabled': ssl_enabled,
            'ssl_keyfile': ssl_keyfile,
            'ssl_certfile': ssl_certfile,
            'model_check_interval': model_check_interval,
            'debug': debug
        }
        self.socket_port = socket_port

        self.initialise_zqm()

    def start_server(self):
        """
        Sets up all the routes for the server and starts it.

        server_backend: bottle.ServerAdapter (default None)
            The server adapter to use. The default bottle.WSGIRefServer is used if none is given.
            WARNING: If given, this will over-ride the host-ip and port passed as parameters to this
            object.
        """
        current_dir = os.path.dirname(os.path.abspath(__file__))
        subprocess_file = f"{current_dir}/subprocess_dcf_server.py"
        command = ' '.join(["python", subprocess_file, str(self.socket_port)])
        # sp.Popen(command, stdout=sys.stdout, stderr=sys.stderr, shell=True)
        self.wait_for_messages()

    def initialise_zqm(self):
        context = zmq.Context()
        self.socket = context.socket(zmq.REP)
        self.socket.bind(f"tcp://*:{self.socket_port}")

    def wait_for_messages(self):
        zqmi = ZQMInterfaceModel(
            socket=self.socket,
            register_worker_callback=self.register_worker_callback,
            unregister_worker_callback=self.unregister_worker_callback,
            return_global_model_callback=self.return_global_model_callback,
            is_global_model_most_recent=self.is_global_model_most_recent,
            receive_worker_update_callback=self.receive_worker_update_callback, 
            server_subprocess_args=self.server_subprocess_args           
        )
        while True:
            #  Wait for next request from client
            logger.info('Waiting for next zqm message...')
            zqmi.receive()
